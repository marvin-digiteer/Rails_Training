// quill-delta@5.1.0 downloaded from https://ga.jspm.io/npm:quill-delta@5.1.0/dist/Delta.js

import*as e from"fast-diff";import*as t from"lodash.clonedeep";import*as n from"lodash.isequal";import s from"./Op.js";var r="default"in t?t.default:t;var i="default"in n?n.default:n;var o={};Object.defineProperty(o,"__esModule",{value:true});const a=r;const u=i;var l;(function(e){function compose(e={},t={},n=false){"object"!==typeof e&&(e={});"object"!==typeof t&&(t={});let s=a(t);n||(s=Object.keys(s).reduce(((e,t)=>{null!=s[t]&&(e[t]=s[t]);return e}),{}));for(const n in e)void 0!==e[n]&&void 0===t[n]&&(s[n]=e[n]);return Object.keys(s).length>0?s:void 0}e.compose=compose;function diff(e={},t={}){"object"!==typeof e&&(e={});"object"!==typeof t&&(t={});const n=Object.keys(e).concat(Object.keys(t)).reduce(((n,s)=>{u(e[s],t[s])||(n[s]=void 0===t[s]?null:t[s]);return n}),{});return Object.keys(n).length>0?n:void 0}e.diff=diff;function invert(e={},t={}){e=e||{};const n=Object.keys(t).reduce(((n,s)=>{t[s]!==e[s]&&void 0!==e[s]&&(n[s]=t[s]);return n}),{});return Object.keys(e).reduce(((n,s)=>{e[s]!==t[s]&&void 0===t[s]&&(n[s]=null);return n}),n)}e.invert=invert;function transform(e,t,n=false){if("object"!==typeof e)return t;if("object"!==typeof t)return;if(!n)return t;const s=Object.keys(t).reduce(((n,s)=>{void 0===e[s]&&(n[s]=t[s]);return n}),{});return Object.keys(s).length>0?s:void 0}e.transform=transform})(l||(l={}));o.default=l;var f={};Object.defineProperty(f,"__esModule",{value:true});const p=s;class Iterator{constructor(e){this.ops=e;this.index=0;this.offset=0}hasNext(){return this.peekLength()<Infinity}next(e){e||(e=Infinity);const t=this.ops[this.index];if(t){const n=this.offset;const s=p.default.length(t);if(e>=s-n){e=s-n;this.index+=1;this.offset=0}else this.offset+=e;if("number"===typeof t.delete)return{delete:e};{const s={};t.attributes&&(s.attributes=t.attributes);"number"===typeof t.retain?s.retain=e:"object"===typeof t.retain&&null!==t.retain?s.retain=t.retain:"string"===typeof t.insert?s.insert=t.insert.substr(n,e):s.insert=t.insert;return s}}return{retain:Infinity}}peek(){return this.ops[this.index]}peekLength(){return this.ops[this.index]?p.default.length(this.ops[this.index])-this.offset:Infinity}peekType(){const e=this.ops[this.index];return e?"number"===typeof e.delete?"delete":"number"===typeof e.retain||"object"===typeof e.retain&&null!==e.retain?"retain":"insert":"retain"}rest(){if(this.hasNext()){if(0===this.offset)return this.ops.slice(this.index);{const e=this.offset;const t=this.index;const n=this.next();const s=this.ops.slice(this.index);this.offset=e;this.index=t;return[n].concat(s)}}return[]}}f.default=Iterator;var c="default"in e?e.default:e;var h="default"in t?t.default:t;var d="default"in n?n.default:n;var b={};Object.defineProperty(b,"__esModule",{value:true});b.AttributeMap=b.OpIterator=b.Op=void 0;const y=c;const m=h;const g=d;const x=o;b.AttributeMap=x.default;const k=s;b.Op=k.default;const j=f;b.OpIterator=j.default;const w=String.fromCharCode(0);const getEmbedTypeAndData=(e,t)=>{if("object"!==typeof e||null===e)throw new Error("cannot retain a "+typeof e);if("object"!==typeof t||null===t)throw new Error("cannot retain a "+typeof t);const n=Object.keys(e)[0];if(!n||n!==Object.keys(t)[0])throw new Error(`embed types not matched: ${n} != ${Object.keys(t)[0]}`);return[n,e[n],t[n]]};class Delta{constructor(e){Array.isArray(e)?this.ops=e:null!=e&&Array.isArray(e.ops)?this.ops=e.ops:this.ops=[]}static registerEmbed(e,t){this.handlers[e]=t}static unregisterEmbed(e){delete this.handlers[e]}static getHandler(e){const t=this.handlers[e];if(!t)throw new Error(`no handlers for embed type "${e}"`);return t}insert(e,t){const n={};if("string"===typeof e&&0===e.length)return this;n.insert=e;null!=t&&"object"===typeof t&&Object.keys(t).length>0&&(n.attributes=t);return this.push(n)}delete(e){return e<=0?this:this.push({delete:e})}retain(e,t){if("number"===typeof e&&e<=0)return this;const n={retain:e};null!=t&&"object"===typeof t&&Object.keys(t).length>0&&(n.attributes=t);return this.push(n)}push(e){let t=this.ops.length;let n=this.ops[t-1];e=m(e);if("object"===typeof n){if("number"===typeof e.delete&&"number"===typeof n.delete){this.ops[t-1]={delete:n.delete+e.delete};return this}if("number"===typeof n.delete&&null!=e.insert){t-=1;n=this.ops[t-1];if("object"!==typeof n){this.ops.unshift(e);return this}}if(g(e.attributes,n.attributes)){if("string"===typeof e.insert&&"string"===typeof n.insert){this.ops[t-1]={insert:n.insert+e.insert};"object"===typeof e.attributes&&(this.ops[t-1].attributes=e.attributes);return this}if("number"===typeof e.retain&&"number"===typeof n.retain){this.ops[t-1]={retain:n.retain+e.retain};"object"===typeof e.attributes&&(this.ops[t-1].attributes=e.attributes);return this}}}t===this.ops.length?this.ops.push(e):this.ops.splice(t,0,e);return this}chop(){const e=this.ops[this.ops.length-1];e&&"number"===typeof e.retain&&!e.attributes&&this.ops.pop();return this}filter(e){return this.ops.filter(e)}forEach(e){this.ops.forEach(e)}map(e){return this.ops.map(e)}partition(e){const t=[];const n=[];this.forEach((s=>{const r=e(s)?t:n;r.push(s)}));return[t,n]}reduce(e,t){return this.ops.reduce(e,t)}changeLength(){return this.reduce(((e,t)=>t.insert?e+k.default.length(t):t.delete?e-t.delete:e),0)}length(){return this.reduce(((e,t)=>e+k.default.length(t)),0)}slice(e=0,t=Infinity){const n=[];const s=new j.default(this.ops);let r=0;while(r<t&&s.hasNext()){let i;if(r<e)i=s.next(e-r);else{i=s.next(t-r);n.push(i)}r+=k.default.length(i)}return new Delta(n)}compose(e){const t=new j.default(this.ops);const n=new j.default(e.ops);const s=[];const r=n.peek();if(null!=r&&"number"===typeof r.retain&&null==r.attributes){let e=r.retain;while("insert"===t.peekType()&&t.peekLength()<=e){e-=t.peekLength();s.push(t.next())}r.retain-e>0&&n.next(r.retain-e)}const i=new Delta(s);while(t.hasNext()||n.hasNext())if("insert"===n.peekType())i.push(n.next());else if("delete"===t.peekType())i.push(t.next());else{const e=Math.min(t.peekLength(),n.peekLength());const s=t.next(e);const r=n.next(e);if(r.retain){const o={};if("number"===typeof s.retain)o.retain="number"===typeof r.retain?e:r.retain;else if("number"===typeof r.retain)null==s.retain?o.insert=s.insert:o.retain=s.retain;else{const e=null==s.retain?"insert":"retain";const[t,n,i]=getEmbedTypeAndData(s[e],r.retain);const a=Delta.getHandler(t);o[e]={[t]:a.compose(n,i,"retain"===e)}}const a=x.default.compose(s.attributes,r.attributes,"number"===typeof s.retain);a&&(o.attributes=a);i.push(o);if(!n.hasNext()&&g(i.ops[i.ops.length-1],o)){const e=new Delta(t.rest());return i.concat(e).chop()}}else"number"===typeof r.delete&&("number"===typeof s.retain||"object"===typeof s.retain&&null!==s.retain)&&i.push(r)}return i.chop()}concat(e){const t=new Delta(this.ops.slice());if(e.ops.length>0){t.push(e.ops[0]);t.ops=t.ops.concat(e.ops.slice(1))}return t}diff(e,t){if(this.ops===e.ops)return new Delta;const n=[this,e].map((t=>t.map((n=>{if(null!=n.insert)return"string"===typeof n.insert?n.insert:w;const s=t===e?"on":"with";throw new Error("diff() called "+s+" non-document")})).join("")));const s=new Delta;const r=y(n[0],n[1],t,true);const i=new j.default(this.ops);const o=new j.default(e.ops);r.forEach((e=>{let t=e[1].length;while(t>0){let n=0;switch(e[0]){case y.INSERT:n=Math.min(o.peekLength(),t);s.push(o.next(n));break;case y.DELETE:n=Math.min(t,i.peekLength());i.next(n);s.delete(n);break;case y.EQUAL:n=Math.min(i.peekLength(),o.peekLength(),t);const e=i.next(n);const r=o.next(n);g(e.insert,r.insert)?s.retain(n,x.default.diff(e.attributes,r.attributes)):s.push(r).delete(n);break}t-=n}}));return s.chop()}eachLine(e,t="\n"){const n=new j.default(this.ops);let s=new Delta;let r=0;while(n.hasNext()){if("insert"!==n.peekType())return;const i=n.peek();const o=k.default.length(i)-n.peekLength();const a="string"===typeof i.insert?i.insert.indexOf(t,o)-o:-1;if(a<0)s.push(n.next());else if(a>0)s.push(n.next(a));else{if(false===e(s,n.next(1).attributes||{},r))return;r+=1;s=new Delta}}s.length()>0&&e(s,{},r)}invert(e){const t=new Delta;this.reduce(((n,s)=>{if(s.insert)t.delete(k.default.length(s));else{if("number"===typeof s.retain&&null==s.attributes){t.retain(s.retain);return n+s.retain}if(s.delete||"number"===typeof s.retain){const r=s.delete||s.retain;const i=e.slice(n,n+r);i.forEach((e=>{s.delete?t.push(e):s.retain&&s.attributes&&t.retain(k.default.length(e),x.default.invert(s.attributes,e.attributes))}));return n+r}if("object"===typeof s.retain&&null!==s.retain){const r=e.slice(n,n+1);const i=new j.default(r.ops).next();const[o,a,u]=getEmbedTypeAndData(s.retain,i.insert);const l=Delta.getHandler(o);t.retain({[o]:l.invert(a,u)},x.default.invert(s.attributes,i.attributes));return n+1}}return n}),0);return t.chop()}transform(e,t=false){t=!!t;if("number"===typeof e)return this.transformPosition(e,t);const n=e;const s=new j.default(this.ops);const r=new j.default(n.ops);const i=new Delta;while(s.hasNext()||r.hasNext())if("insert"!==s.peekType()||!t&&"insert"===r.peekType())if("insert"===r.peekType())i.push(r.next());else{const e=Math.min(s.peekLength(),r.peekLength());const n=s.next(e);const o=r.next(e);if(n.delete)continue;if(o.delete)i.push(o);else{const s=n.retain;const r=o.retain;let a="object"===typeof r&&null!==r?r:e;if("object"===typeof s&&null!==s&&"object"===typeof r&&null!==r){const e=Object.keys(s)[0];if(e===Object.keys(r)[0]){const n=Delta.getHandler(e);n&&(a={[e]:n.transform(s[e],r[e],t)})}}i.retain(a,x.default.transform(n.attributes,o.attributes,t))}}else i.retain(k.default.length(s.next()));return i.chop()}transformPosition(e,t=false){t=!!t;const n=new j.default(this.ops);let s=0;while(n.hasNext()&&s<=e){const r=n.peekLength();const i=n.peekType();n.next();if("delete"!==i){"insert"===i&&(s<e||!t)&&(e+=r);s+=r}else e-=Math.min(r,e-s)}return e}}Delta.Op=k.default;Delta.OpIterator=j.default;Delta.AttributeMap=x.default;Delta.handlers={};b.default=Delta;b=Delta;b.default=Delta;var v=b;const O=b.__esModule,D=b.AttributeMap,L=b.OpIterator,E=b.Op;export{D as AttributeMap,E as Op,L as OpIterator,O as __esModule,v as default};

